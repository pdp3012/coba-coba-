//@version=5
strategy("Frequency Analyzer Strategy", shorttitle="FreqAnalyzer Strategy", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_type=strategy.commission.percent, commission_value=0.1)

// ============================================================================
// STRATEGY PARAMETERS
// ============================================================================
// Risk Management
use_stop_loss = input.bool(true, "Use Stop Loss")
stop_loss_percent = input.float(2.0, "Stop Loss (%)", minval=0.5, maxval=10.0, step=0.1)
use_take_profit = input.bool(true, "Use Take Profit")
take_profit_percent = input.float(4.0, "Take Profit (%)", minval=1.0, maxval=20.0, step=0.1)
use_trailing_stop = input.bool(false, "Use Trailing Stop")
trailing_stop_percent = input.float(1.5, "Trailing Stop (%)", minval=0.5, maxval=5.0, step=0.1)

// Position Sizing
max_positions = input.int(3, "Maximum Concurrent Positions", minval=1, maxval=10)
position_size_percent = input.float(10.0, "Position Size (% of Equity)", minval=5.0, maxval=50.0, step=1.0)

// Frequency Analyzer Settings
fft_length = input.int(64, "FFT Length", minval=16, maxval=256)
dominant_cycles = input.int(5, "Number of Dominant Cycles", minval=1, maxval=10)
cycle_threshold = input.float(0.1, "Cycle Strength Threshold", minval=0.01, maxval=1.0, step=0.01)
signal_sensitivity = input.float(0.7, "Signal Sensitivity", minval=0.1, maxval=1.0, step=0.1)

// Additional Filters
use_volume_filter = input.bool(true, "Use Volume Filter")
volume_threshold = input.float(1.5, "Volume Threshold (x Average)", minval=1.0, maxval=5.0, step=0.1)
use_trend_filter = input.bool(true, "Use Trend Filter")
trend_period = input.int(20, "Trend Period", minval=10, maxval=50)

// ============================================================================
// FREQUENCY ANALYZER IMPLEMENTATION
// ============================================================================
var float[] price_buffer = array.new_float(0)
var float[] fft_real = array.new_float(0)
var float[] fft_imag = array.new_float(0)
var float[] power_spectrum = array.new_float(0)
var float[] dominant_periods = array.new_float(0)

// Update price buffer
if barstate.islast
    array.clear(price_buffer)
    for i = 0 to fft_length - 1
        if barstate.islast[i]
            array.push(price_buffer, close[i])
        else
            array.push(price_buffer, 0.0)

// FFT Analysis
fft_analysis() =>
    if array.size(price_buffer) < fft_length
        return
    
    array.clear(fft_real)
    array.clear(fft_imag)
    array.clear(power_spectrum)
    array.clear(dominant_periods)
    
    // Initialize FFT arrays
    for i = 0 to fft_length - 1
        array.push(fft_real, array.get(price_buffer, i))
        array.push(fft_imag, 0.0)
    
    // Simple FFT implementation
    fft_simple(fft_real, fft_imag, fft_length)
    
    // Calculate power spectrum
    for i = 0 to fft_length - 1
        real_val = array.get(fft_real, i)
        imag_val = array.get(fft_imag, i)
        power = math.sqrt(real_val * real_val + imag_val * imag_val)
        array.push(power_spectrum, power)
    
    // Find dominant cycles
    find_dominant_cycles()

// Simple FFT implementation
fft_simple(real_array, imag_array, n) =>
    if n <= 1
        return
    
    // Split arrays
    even_real = array.new_float(0)
    even_imag = array.new_float(0)
    odd_real = array.new_float(0)
    odd_imag = array.new_float(0)
    
    for i = 0 to n - 1
        if i % 2 == 0
            array.push(even_real, array.get(real_array, i))
            array.push(even_imag, array.get(imag_array, i))
        else
            array.push(odd_real, array.get(real_array, i))
            array.push(odd_imag, array.get(imag_array, i))
    
    // Recursive calls
    fft_simple(even_real, even_imag, n / 2)
    fft_simple(odd_real, odd_imag, n / 2)
    
    // Combine results
    for k = 0 to n / 2 - 1
        angle = -2.0 * math.pi * k / n
        cos_val = math.cos(angle)
        sin_val = math.sin(angle)
        
        even_real_k = array.get(even_real, k)
        even_imag_k = array.get(even_imag, k)
        odd_real_k = array.get(odd_real, k)
        odd_imag_k = array.get(odd_imag, k)
        
        temp_real = cos_val * odd_real_k - sin_val * odd_imag_k
        temp_imag = sin_val * odd_real_k + cos_val * odd_imag_k
        
        array.set(real_array, k, even_real_k + temp_real)
        array.set(imag_array, k, even_imag_k + temp_imag)
        array.set(real_array, k + n / 2, even_real_k - temp_real)
        array.set(imag_array, k + n / 2, even_imag_k - temp_imag)

// Find dominant cycles
find_dominant_cycles() =>
    if array.size(power_spectrum) < 2
        return
    
    var float[] sorted_powers = array.copy(power_spectrum)
    array.remove(sorted_powers, 0)
    
    // Simple sorting
    for i = 0 to array.size(sorted_powers) - 1
        for j = 0 to array.size(sorted_powers) - i - 2
            if array.get(sorted_powers, j) < array.get(sorted_powers, j + 1)
                temp = array.get(sorted_powers, j)
                array.set(sorted_powers, j, array.get(sorted_powers, j + 1))
                array.set(sorted_powers, j + 1, temp)
    
    // Find dominant cycles above threshold
    threshold = array.get(sorted_powers, 0) * cycle_threshold
    count = 0
    
    for i = 0 to array.size(sorted_powers) - 1
        if count >= dominant_cycles
            break
        
        if array.get(sorted_powers, i) >= threshold
            frequency = (i + 1) / fft_length
            period = 1.0 / frequency
            
            if period > 1 and period < fft_length
                array.push(dominant_periods, period)
                count += 1

// Calculate signal strength
calculate_signal_strength() =>
    if array.size(dominant_periods) == 0
        return 0.0
    
    // Calculate weighted average of dominant periods
    total_weight = 0.0
    weighted_sum = 0.0
    
    for i = 0 to array.size(dominant_periods) - 1
        period = array.get(dominant_periods, i)
        weight = array.get(power_spectrum, math.round(period))
        weighted_sum += period * weight
        total_weight += weight
    
    if total_weight == 0
        return 0.0
    
    avg_period = weighted_sum / total_weight
    
    // Calculate signal based on cycle position
    cycle_position = bar_index % math.round(avg_period)
    cycle_progress = cycle_position / math.round(avg_period)
    
    // Generate signal
    if cycle_progress < 0.25 or cycle_progress > 0.75
        signal = 1.0 * signal_sensitivity
    else if cycle_progress > 0.4 and cycle_progress < 0.6
        signal = -1.0 * signal_sensitivity
    else
        signal = 0.0
    
    signal

// ============================================================================
// ADDITIONAL FILTERS
// ============================================================================
// Volume filter
volume_filter() =>
    if not use_volume_filter
        true
    else
        avg_volume = ta.sma(volume, 20)
        current_volume > avg_volume * volume_threshold

// Trend filter
trend_filter() =>
    if not use_trend_filter
        true
    else
        trend_sma = ta.sma(close, trend_period)
        close > trend_sma

// ============================================================================
// MAIN EXECUTION
// ============================================================================
if barstate.islast
    fft_analysis()

signal_strength = calculate_signal_strength()

// ============================================================================
// STRATEGY LOGIC
// ============================================================================
// Entry conditions
long_condition = signal_strength > signal_sensitivity and volume_filter() and trend_filter() and strategy.position_size == 0
short_condition = signal_strength < -signal_sensitivity and volume_filter() and not trend_filter() and strategy.position_size == 0

// Position management
if long_condition
    strategy.entry("Long", strategy.long, qty=strategy.equity * position_size_percent / 100 / close)
    
    if use_stop_loss
        strategy.exit("Long Exit", "Long", stop=strategy.position_avg_price * (1 - stop_loss_percent / 100))
    
    if use_take_profit
        strategy.exit("Long TP", "Long", limit=strategy.position_avg_price * (1 + take_profit_percent / 100))

if short_condition
    strategy.entry("Short", strategy.short, qty=strategy.equity * position_size_percent / 100 / close)
    
    if use_stop_loss
        strategy.exit("Short Exit", "Short", stop=strategy.position_avg_price * (1 + stop_loss_percent / 100))
    
    if use_take_profit
        strategy.exit("Short TP", "Short", limit=strategy.position_avg_price * (1 - take_profit_percent / 100))

// Trailing stop
if use_trailing_stop and strategy.position_size != 0
    if strategy.position_size > 0
        strategy.exit("Trailing Stop Long", "Long", trail_points=close * trailing_stop_percent / 100 * syminfo.pointvalue)
    else
        strategy.exit("Trailing Stop Short", "Short", trail_points=close * trailing_stop_percent / 100 * syminfo.pointvalue)

// ============================================================================
// PLOTTING
// ============================================================================
// Plot entry signals
plotshape(long_condition, "Long Entry", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(short_condition, "Short Entry", shape.triangledown, location.abovebar, color.red, size=size.small)

// Plot signal strength
hline(signal_sensitivity, "Bullish Threshold", color=color.green, linestyle=hline.style_dotted)
hline(-signal_sensitivity, "Bearish Threshold", color=color.red, linestyle=hline.style_dotted)
hline(0, "Zero Line", color=color.gray, linestyle=hline.style_dashed)

// ============================================================================
// TABLE DISPLAY
// ============================================================================
if barstate.islast
    var table strategy_table = table.new(position.top_left, 2, 8, bgcolor=color.white, border_width=1)
    
    table.cell(strategy_table, 0, 0, "Frequency Strategy", text_color=color.black, bgcolor=color.blue)
    table.cell(strategy_table, 1, 0, "Status", text_color=color.black, bgcolor=color.blue)
    
    table.cell(strategy_table, 0, 1, "Signal Strength", text_color=color.black)
    table.cell(strategy_table, 1, 1, str.tostring(signal_strength, "#.##"), 
               text_color=signal_strength > 0 ? color.green : signal_strength < 0 ? color.red : color.gray)
    
    table.cell(strategy_table, 0, 2, "Position", text_color=color.black)
    table.cell(strategy_table, 1, 2, strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT", 
               text_color=strategy.position_size > 0 ? color.green : strategy.position_size < 0 ? color.red : color.gray)
    
    table.cell(strategy_table, 0, 3, "Equity", text_color=color.black)
    table.cell(strategy_table, 1, 3, str.tostring(strategy.equity, "#.##"), text_color=color.black)
    
    table.cell(strategy_table, 0, 4, "Total Trades", text_color=color.black)
    table.cell(strategy_table, 1, 4, str.tostring(strategy.closedtrades), text_color=color.black)
    
    table.cell(strategy_table, 0, 5, "Win Rate", text_color=color.black)
    win_rate = strategy.closedtrades > 0 ? (strategy.wintrades / strategy.closedtrades) * 100 : 0
    table.cell(strategy_table, 1, 5, str.tostring(win_rate, "#.#") + "%", 
               text_color=win_rate > 50 ? color.green : color.red)
    
    table.cell(strategy_table, 0, 6, "Dominant Cycles", text_color=color.black)
    table.cell(strategy_table, 1, 6, str.tostring(array.size(dominant_periods)), text_color=color.black)
    
    table.cell(strategy_table, 0, 7, "Volume Filter", text_color=color.black)
    table.cell(strategy_table, 1, 7, volume_filter() ? "PASS" : "FAIL", 
               text_color=volume_filter() ? color.green : color.red)