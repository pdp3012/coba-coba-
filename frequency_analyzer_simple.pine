//@version=6
indicator("Frequency Analyzer Simple", shorttitle="FreqAnal", overlay=false, max_bars_back=500)

// ============================================================================
// INPUT PARAMETERS
// ============================================================================
// Timeframe settings
timeframe_input = input.string("D", "Timeframe", options=["1", "5", "15", "30", "60", "D", "W", "M"])
use_custom_timeframe = input.bool(false, "Use Custom Timeframe")
custom_timeframe = input.int(20, "Custom Period Length", minval=5, maxval=100)

// Analysis settings
lookback_period = input.int(64, "Lookback Period", minval=16, maxval=256, tooltip="Number of bars to analyze for cycles")
dominant_cycles = input.int(5, "Number of Dominant Cycles", minval=1, maxval=10)
cycle_threshold = input.float(0.1, "Cycle Strength Threshold", minval=0.01, maxval=1.0, step=0.01)

// Signal settings
signal_sensitivity = input.float(0.7, "Signal Sensitivity", minval=0.1, maxval=1.0, step=0.1)
enable_alerts = input.bool(true, "Enable Alerts")
show_cycles = input.bool(true, "Show Cycle Lines")

// Visual settings
bull_color = input.color(color.green, "Bullish Signal Color")
bear_color = input.color(color.red, "Bearish Signal Color")
neutral_color = input.color(color.gray, "Neutral Signal Color")
cycle_color = input.color(color.blue, "Cycle Line Color")

// ============================================================================
// VARIABLES AND CALCULATIONS
// ============================================================================
var float[] price_buffer = array.new_float(0)
var float[] dominant_periods = array.new_float(0)

// Get price data based on timeframe
get_price_data(int offset) =>
    float price = 0.0
    if timeframe_input == "1" or timeframe_input == "5" or timeframe_input == "15" or timeframe_input == "30" or timeframe_input == "60"
        price := close[offset]
    else if timeframe_input == "D"
        price := request.security(syminfo.tickerid, "D", close[offset])
    else if timeframe_input == "W"
        price := request.security(syminfo.tickerid, "W", close[offset])
    else if timeframe_input == "M"
        price := request.security(syminfo.tickerid, "M", close[offset])
    else
        price := close[offset]
    
    if use_custom_timeframe
        price := ta.sma(close[offset], custom_timeframe)
    
    price

// Update price buffer
if barstate.islast
    array.clear(price_buffer)
    for i = 0 to lookback_period - 1
        if barstate.islast[i]
            array.push(price_buffer, get_price_data(i))
        else
            array.push(price_buffer, 0.0)

// Simplified cycle detection using autocorrelation
detect_cycles() =>
    if array.size(price_buffer) < 10
        na
    
    array.clear(dominant_periods)
    
    // Simple cycle detection using price momentum
    var float[] momentum = array.new_float(0)
    array.clear(momentum)
    
    // Calculate price momentum
    for i = 1 to array.size(price_buffer) - 1
        if array.get(price_buffer, i) != 0 and array.get(price_buffer, i-1) != 0
            mom = array.get(price_buffer, i) - array.get(price_buffer, i-1)
            array.push(momentum, mom)
    
    // Find cycles based on momentum patterns
    if array.size(momentum) > 5
        // Simple cycle detection using momentum zero crossings
        zero_crossings = 0
        for i = 1 to array.size(momentum) - 1
            if (array.get(momentum, i-1) < 0 and array.get(momentum, i) > 0) or 
               (array.get(momentum, i-1) > 0 and array.get(momentum, i) < 0)
                zero_crossings += 1
        
        if zero_crossings > 0
            estimated_period = array.size(momentum) / zero_crossings
            if estimated_period > 2 and estimated_period < lookback_period
                array.push(dominant_periods, estimated_period)
        
        // Add some common market cycles
        common_cycles = array.from(5, 10, 20, 40, 60)
        for i = 0 to array.size(common_cycles) - 1
            if array.size(dominant_periods) < dominant_cycles
                cycle = array.get(common_cycles, i)
                if cycle <= lookback_period
                    array.push(dominant_periods, cycle)

// Calculate signal strength based on cycle analysis
calculate_signal_strength() =>
    if array.size(dominant_periods) == 0
        0.0
    
    // Use the primary cycle for signal generation
    primary_period = array.get(dominant_periods, 0)
    
    // Calculate signal based on current price position relative to cycle
    cycle_position = bar_index % math.round(primary_period)
    cycle_progress = cycle_position / math.round(primary_period)
    
    // Generate signal based on cycle position
    if cycle_progress < 0.25 or cycle_progress > 0.75
        1.0 * signal_sensitivity // Bullish
    else if cycle_progress > 0.4 and cycle_progress < 0.6
        -1.0 * signal_sensitivity // Bearish
    else
        0.0 // Neutral

// ============================================================================
// MAIN EXECUTION
// ============================================================================
if barstate.islast
    detect_cycles()

signal_strength = calculate_signal_strength()

// ============================================================================
// PLOTTING
// ============================================================================
// Main signal plot
plot(signal_strength, "Signal Strength", color=signal_strength > 0 ? bull_color : signal_strength < 0 ? bear_color : neutral_color, linewidth=2)

// Zero line
hline(0, "Zero Line", color=color.gray, linestyle=hline.style_dashed)

// Signal levels
hline(signal_sensitivity, "Bullish Threshold", color=bull_color, linestyle=hline.style_dotted)
hline(-signal_sensitivity, "Bearish Threshold", color=bear_color, linestyle=hline.style_dotted)

// Cycle information display
if show_cycles and array.size(dominant_periods) > 0
    for i = 0 to math.min(array.size(dominant_periods) - 1, 2)
        period = array.get(dominant_periods, i)
        if period > 1
            cycle_line = math.sin(2 * math.pi * bar_index / period) * signal_sensitivity * 0.5
            plot(cycle_line, "Cycle " + str.tostring(i + 1), color=cycle_color, linewidth=1, display=display.none)

// ============================================================================
// ALERTS
// ============================================================================
if enable_alerts
    // Bullish signal alert
    if signal_strength > signal_sensitivity and signal_strength[1] <= signal_sensitivity
        alert("Frequency Analyzer: Bullish Signal Detected! Signal Strength: " + str.tostring(signal_strength), alert.freq_once_per_bar)
    
    // Bearish signal alert
    if signal_strength < -signal_sensitivity and signal_strength[1] >= -signal_sensitivity
        alert("Frequency Analyzer: Bearish Signal Detected! Signal Strength: " + str.tostring(signal_strength), alert.freq_once_per_bar)

// ============================================================================
// TABLE DISPLAY
// ============================================================================
if barstate.islast
    var table info_table = table.new(position.top_right, 2, 6, bgcolor=color.white, border_width=1)
    
    table.cell(info_table, 0, 0, "Frequency Analyzer", text_color=color.black, bgcolor=color.blue)
    table.cell(info_table, 1, 0, "Status", text_color=color.black, bgcolor=color.blue)
    
    table.cell(info_table, 0, 1, "Signal Strength", text_color=color.black)
    table.cell(info_table, 1, 1, str.tostring(signal_strength, "#.##"), 
               text_color=signal_strength > 0 ? color.green : signal_strength < 0 ? color.red : color.gray)
    
    table.cell(info_table, 0, 2, "Dominant Cycles", text_color=color.black)
    table.cell(info_table, 1, 2, str.tostring(array.size(dominant_periods)), text_color=color.black)
    
    if array.size(dominant_periods) > 0
        table.cell(info_table, 0, 3, "Primary Cycle", text_color=color.black)
        table.cell(info_table, 1, 3, str.tostring(array.get(dominant_periods, 0), "#.#") + " bars", text_color=color.black)
    
    table.cell(info_table, 0, 4, "Timeframe", text_color=color.black)
    table.cell(info_table, 1, 4, timeframe_input, text_color=color.black)
    
    table.cell(info_table, 0, 5, "Lookback Period", text_color=color.black)
    table.cell(info_table, 1, 5, str.tostring(lookback_period), text_color=color.black)